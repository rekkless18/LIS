import { create } from 'zustand';
import { persist } from 'zustand/middleware';
export type ExperimentStatus = 'pending' | 'running' | 'exception' | 'reviewing' | 'reviewed' | 'cancelled';
export type AuditStatus = 'pending' | 'approved' | 'rejected';
export interface ExperimentItemResult { id: string; name: string; range: string; unit: string; value: string; interpretation: string; }
export interface ExperimentTask { id: string; sampleNo: string; productName: string; status: ExperimentStatus; auditStatus: AuditStatus; equipment: string; startTime?: string; endTime?: string; auditTime?: string; auditor?: string; items: ExperimentItemResult[]; }
export interface RoutineFilters { sampleNos?: string[]; productIds?: string[]; statuses?: ExperimentStatus[]; auditStatuses?: AuditStatus[]; startRange?: [string, string]; endRange?: [string, string]; auditRange?: [string, string]; }
export interface PaginationConfig { current: number; pageSize: number; total: number; showSizeChanger: boolean; pageSizeOptions: string[]; }
interface RoutineState { tasks: ExperimentTask[]; filteredTasks: ExperimentTask[]; selectedRowKeys: string[]; currentTask: ExperimentTask | null; filters: RoutineFilters; pagination: PaginationConfig; loading: boolean; }
interface RoutineActions { setTasks: (tasks: ExperimentTask[]) => void; setFilteredTasks: (tasks: ExperimentTask[]) => void; setSelectedRowKeys: (keys: string[]) => void; setCurrentTask: (task: ExperimentTask | null) => void; setFilters: (filters: Partial<RoutineFilters>) => void; resetFilters: () => void; setPagination: (pagination: Partial<PaginationConfig>) => void; queryTasks: () => void; approve: (ids: string[]) => void; retest: (ids: string[]) => void; cancel: (ids: string[]) => void; }
const defaultFilters: RoutineFilters = { statuses: ['pending', 'running', 'exception', 'reviewing'] };
const defaultPagination: PaginationConfig = { current: 1, pageSize: 20, total: 0, showSizeChanger: true, pageSizeOptions: ['10','20','50','100'] };
const tasksMock: ExperimentTask[] = [
  { id: 't1', sampleNo: 'SMP001', productName: '外显子组测序', status: 'running', auditStatus: 'pending', equipment: 'Illumina NovaSeq X - EQ001', startTime: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(), items: [ { id: 'i1', name: '覆盖度', range: '≥ 98%', unit: '%', value: '98.7', interpretation: '合格' }, { id: 'i2', name: 'Q30比例', range: '≥ 85%', unit: '%', value: '92.3', interpretation: '合格' } ] },
  { id: 't2', sampleNo: 'SMP010', productName: 'ctDNA检测', status: 'pending', auditStatus: 'pending', equipment: 'NextSeq 2000 - EQ002', items: [ { id: 'i3', name: '捕获效率', range: '≥ 50%', unit: '%', value: '48.0', interpretation: '警告' }, { id: 'i4', name: '重复率', range: '≤ 10%', unit: '%', value: '12.5', interpretation: '不合格' } ] },
  { id: 't3', sampleNo: 'SMP020', productName: '肿瘤标志物检测', status: 'exception', auditStatus: 'pending', equipment: 'Liquid Handler - EQ010', startTime: new Date(Date.now() - 5 * 60 * 60 * 1000).toISOString(), endTime: new Date(Date.now() - 4 * 60 * 60 * 1000).toISOString(), items: [ { id: 'i5', name: '样本体积', range: '≥ 2ml', unit: 'ml', value: '1.5', interpretation: '不合格' } ] },
  { id: 't4', sampleNo: 'SMP030', productName: '全基因组测序', status: 'reviewing', auditStatus: 'pending', equipment: 'MGI DNBSEQ-T7 - EQ003', startTime: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(), endTime: new Date(Date.now() - 22 * 60 * 60 * 1000).toISOString(), items: [ { id: 'i6', name: '测序深度', range: '≥ 30X', unit: 'X', value: '32', interpretation: '合格' } ] }
];
export const useRoutineStore = create<RoutineState & RoutineActions>()(persist((set, get) => ({
  tasks: tasksMock, filteredTasks: [], selectedRowKeys: [], currentTask: null, filters: defaultFilters, pagination: defaultPagination, loading: false,
  setTasks: (tasks) => set({ tasks }), setFilteredTasks: (filteredTasks) => set({ filteredTasks }), setSelectedRowKeys: (selectedRowKeys) => set({ selectedRowKeys }), setCurrentTask: (task) => set({ currentTask: task }), setFilters: (filters) => set((state) => ({ filters: { ...state.filters, ...filters } })), resetFilters: () => set({ filters: defaultFilters }), setPagination: (pagination) => set((state) => ({ pagination: { ...state.pagination, ...pagination } })),
  queryTasks: () => { const { tasks, filters, pagination } = get(); let filtered = [...tasks]; if (filters.sampleNos?.length) { filtered = filtered.filter(t => filters.sampleNos!.some(no => t.sampleNo.includes(no))); } if (filters.productIds?.length) { filtered = filtered.filter(t => filters.productIds!.some(pid => t.productName.includes(pid))); } if (filters.statuses?.length) { filtered = filtered.filter(t => filters.statuses!.includes(t.status)); } if (filters.auditStatuses?.length) { filtered = filtered.filter(t => filters.auditStatuses!.includes(t.auditStatus)); } if (filters.startRange?.[0] && filters.startRange?.[1]) { const [start, end] = filters.startRange; filtered = filtered.filter(t => { const dt = t.startTime ? new Date(t.startTime) : null; return dt ? dt >= new Date(start) && dt <= new Date(end) : false; }); } if (filters.endRange?.[0] && filters.endRange?.[1]) { const [start, end] = filters.endRange; filtered = filtered.filter(t => { const dt = t.endTime ? new Date(t.endTime) : null; return dt ? dt >= new Date(start) && dt <= new Date(end) : false; }); } if (filters.auditRange?.[0] && filters.auditRange?.[1]) { const [start, end] = filters.auditRange; filtered = filtered.filter(t => { const dt = t.auditTime ? new Date(t.auditTime) : null; return dt ? dt >= new Date(start) && dt <= new Date(end) : false; }); } filtered.sort((a, b) => { const aTime = a.startTime ? new Date(a.startTime).getTime() : 0; const bTime = b.startTime ? new Date(b.startTime).getTime() : 0; return bTime - aTime; }); const startIdx = (pagination.current - 1) * pagination.pageSize; const endIdx = startIdx + pagination.pageSize; const paginated = filtered.slice(startIdx, endIdx); set({ filteredTasks: paginated, pagination: { ...pagination, total: filtered.length } }); },
  approve: (ids) => { set((state) => ({ tasks: state.tasks.map(t => ids.includes(t.id) ? { ...t, auditStatus: 'approved', status: 'reviewed', auditTime: new Date().toISOString(), auditor: 'admin' } : t), selectedRowKeys: state.selectedRowKeys.filter(k => !ids.includes(k)) })); },
  retest: (ids) => { set((state) => ({ tasks: state.tasks.map(t => ids.includes(t.id) ? { ...t, status: 'pending', auditStatus: 'pending' } : t), selectedRowKeys: state.selectedRowKeys.filter(k => !ids.includes(k)) })); },
  cancel: (ids) => { set((state) => ({ tasks: state.tasks.map(t => ids.includes(t.id) ? { ...t, status: 'cancelled' } : t), selectedRowKeys: state.selectedRowKeys.filter(k => !ids.includes(k)) })); }
}), { name: 'routine-store', partialize: (state) => ({ tasks: state.tasks, filters: state.filters, pagination: state.pagination }) }));
export type { RoutineState, RoutineActions };
